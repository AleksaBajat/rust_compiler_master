\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{hyperref}
\usepackage{listings}
\usepackage{caption}
\usepackage{minted}
\usepackage[
    protrusion=true,
    activate={true,nocompatibility},
    final,
    tracking=true,
    kerning=true,
    spacing=true,
    factor=1100]{microtype}
\SetTracking{encoding={*}, shape=sc}{40}
\renewcommand{\listingscaption}{Izvorni kod}
\renewcommand{\listoflistingscaption}{Spisak izvornih kodova}

\title{Reprezentacija izvornog koda - Rust kompajler}
\author{Aleksa Bajat}
\date{September 2024}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Uvod}

U svetu razvoja sistema visokih performansi, operativnih sistema, drajvera i bilo kog drugog kritičnog softvera koriste se jezici niskog nivoa kao što su C i C++.
Tokom godina Microsoft je uvideo da je preko 70\% bezbednosnih slabosti nastalo pogrešnom manipulacijom i korupcijom memorije [1]. 
C nema odbrambene mehanizme od ovakvih problema (pored potencijalnih dodatnih upozorenja koja se mogu ostvariti dvostrukom upotrebom GCC i Clang kompajlera), dok C++ uprkos dodavanju konstrukta kao što su \verb|unique_ptr|, \verb|shared_ptr| i \verb|weak_ptr| interoperabilnost sa starijim standardima ili bibliotekama zahteva korišćenje sirovih pokazivača. 

Rust jezik je nastao sa ciljem da reši ovaj problem. Podrazumevana upotreba jezika je inherentno bezbedna sa aspekta memorije i paralelizma. Bezbednost se ostvaruje robustnim sistemom tipova, novog načina rukovanja memorijom i veoma striktnog \verb|rustc| kompajlera.
U C++ ekosistemu koriste se softverski obrasci kao što je \verb|Scope-bound Resource Management| da bi se standardizovala alokacija i dealkoacija memorije, ali korisnik jezika nije primoran da softvrski obrazac upotrebi. U Rust jeziku izbor ne postoji, na kraju svakog opsega vrši se automatska dealokacija memorije preko \verb|borrow checker| mehanizma (nije potreban manuelni poziv \verb|free|).
C i C++ poseduju veoma dvosmislene i neprecizne poruke kada se greška dogodi dok Rust jezik karakterišu veoma precizne poruke koje opisuju gde se desila greška i kako je potencijalno rešiti.

Prvobitna verzija Rust kompajlera je napisana u \verb|O'Caml| jeziku, dok je svaka sledeća verzija napisana u samom Rust-u.
Medjutim treba imati na umu da je Rust samo \verb|frontend| nad \verb|LLVM|-om. LLVM je kolekcija modularnih i ponovo iskoristivih tehnologija za izradu kompajlera. Rust se oslanja u potpunosti na \verb|LLVM| prilikom generisanja mašinskog koda, dok je svaki drugi deo
(\verb|frontend|) napisan potpuno ispočetka.
Veliki deo Rust jezika je izuzetno inovativan i samim tim to je razlog da se detaljno istraži kako u pozadini funkcioniše.

Reprezentacija izvornog koda jeste prikaz ili skup prikaza izvornog koda korisnika jezika da bi se obezbedili tipovi, dijagnostika,
automatska dealokacija memorije i ostali ergonomski i funkcionalni delovi jezika.
\newpage


\section{Verzije Rust kompajlera}

Rust kompajler u svakom trenutku poseduje tri glavne verzije skupa alata (\verb|toolchain|):

\begin{enumerate}
    \item \verb|Stable| - preporučena za svakodnevnu upotrebu. 
    \item \verb|Beta| - sa funkcionalnostima koje se usvajaju u sledećoj stabilnoj verziji (\verb|beta| postaje \verb|stable|).
    \item \verb|Nightly| - sa eksperimentalnim/nestabilnim funkcionalnostima. 
\end{enumerate}

\verb|Toolchain| se može promeniti na više načina ali najjednostavniji je:
\begin{verbatim}
    rustup toolchain install [version]
    rustup override set [version]
\end{verbatim}

Prikaz dostupnih lokalnih verzija, kao i trenutna aktivna verzija se može prikazati upotrebom (izlaz prikazan ispod naredbe):
\begin{verbatim}
    rustup show

    installed toolchains
    --------------------
    
    stable-x86_64-unknown-linux-gnu (default)
    nightly-2024-06-30-x86_64-unknown-linux-gnu
    nightly-2024-07-02-x86_64-unknown-linux-gnu
    nightly-x86_64-unknown-linux-gnu
    stage0
    stage1
    
    active toolchain
    ----------------

    nightly-x86_64-unknown-linux-gnu (directory 
    override for '/home/abajat/Documents/projects/master')
    rustc 1.83.0-nightly (12b26c13f 2024-09-07)
\end{verbatim}

Rust ima obećanje da će zauvek biti kompatibilan unazad uprkos konstantnom razvoju.

\newpage

\section{Upotreba Rust kompajlera}

Rust kompajler \verb|rustc| sa sastoji iz izuzetno velikog broja modula. 
Medjutim upotreba kompajlera je krajnje jednostavna.
Izvorni kod se prenese u tekstualni dokument i poziva se sledeća naredba:
\begin{verbatim}
    rustc filename.rs
\end{verbatim}
nakon čega se kreira izvršni fajl pod istim imenom (pod uslovom da je kod ispravan).

Napredni korisnici Rust-a upotrebom promenljivih okruženja i zastavica funkcionalnosti 
(\verb|feature flag|) uvode ili menjaju osnovno ponašanje \verb|rustc| kompajlera.
Funkcionalnosti korisne za razvoj Rust kompajlera su omogućene samo u \verb|Nightly| verziji koje se
ispoljavaju preko -Z (nestabilnih) zastavica. Mogu se prikazati upotrebom:

\begin{verbatim}
    rustc -C help # stable
    rustc -Z help # unstable
\end{verbatim}


\section{Reprezentacije izvornog koda}

Reprezentacije izvornog koda Rust-a se dele na:

\begin{enumerate}    
    \item Tok tokena
    \item Apstraktno sintaksno stablo
    \item Posredna reprezentacija visokog nivoa
    \item Tipizirana reprezentacija visokog nivoa
    \item Reprezentacija srednjeg nivoa
    \item LLVM reprezentacija
\end{enumerate}


\subsection{Tok tokena}

Programski jezici se generalno odlučuju da implementiraju lekser kao konačni automat uz pomoć alata kao što je
\verb|Flex|. Ipak, u jeziku Rust lekser je implementiran ručno. Ovo omogućava finu granularnost i visoku 
kontrolu nad procesom tokenizacije. Sa obzirom da je cilj Rust-a transparentne i veoma korisne poruke o 
grešci, ovo je veoma smislena implementaciona odluka.
Kompajler poseduje naizgled dva leksera. Lekser niskog nivoa je \verb|rustc_lexer|, a lekser visokog nivoa je \verb|rustc_parse::lexer|. 
Obe implementacije su važne jer \verb|rusc_parse::lexer| koristi \verb|rustc_lexer| tokom kompajliranja.

\subsubsection{rustc\_lexer}

\verb|rustc_lexer| je lekser niskog nivoa koji poseduje sve osnovne
funkcionalnosti potrebne prilikom prikupljanja leksema.
Glavna funkcija iz ovog modula jeste \verb|tokenize| koja na osnovu celokupnog teksta 
izvornog koda dobavlja skup tokena tj. leksema.

\begin{listing}[H]
\begin{minted}{rust}
/// Creates an iterator that produces tokens from the input string.
pub fn tokenize(input: &str) -> impl Iterator<Item = Token> + '_ {
    let mut cursor = Cursor::new(input);
    std::iter::from_fn(move || {
        let token = cursor.advance_token();
        if token.kind != TokenKind::Eof { Some(token) } else { None }
    })
}
\end{minted}
\caption{Ulazna funkcija leksera}
\end{listing}

Implementacija je bazirana na kursoru i unutar te strukture se nalazi celokupna logika leksera. 
Kursor je realizovan pomoću Rust-ovog iteratora i na osnovu njega prati trenutnu poziciju 
unutar izvornog koda. Veoma je bitna mogućnost gledanja ispred (\verb|look-ahead|) koja omogućava 
izvršavanje u jednom prolasku.

\begin{listing}[H]
\begin{minted}{rust}
    /// Peeks the first symbol from the input stream without consuming it.
    pub fn first(&self) -> char {
        // `.next()` optimizes better than `.nth(0)`
        self.chars.clone().next().unwrap_or(EOF_CHAR)
    }

    /// Peeks the second symbol from the input stream without consuming it.
    pub(crate) fn second(&self) -> char {
        // `.next()` optimizes better than `.nth(1)`
        let mut iter = self.chars.clone();
        iter.next();
        iter.next().unwrap_or(EOF_CHAR)
    }

    /// Peeks the third symbol from the input stream without consuming it.
    pub fn third(&self) -> char {
        // `.next()` optimizes better than `.nth(1)`
        let mut iter = self.chars.clone();
        iter.next();
        iter.next();
        iter.next().unwrap_or(EOF_CHAR)
    }
\end{minted}
\caption{"Look-ahead" mehanizam}
\end{listing}
Kloniranje iteratora je jeftina operacija jer se svodi na kopiranje trenutne adresa.

\verb|Token| sadrži samo informaciju o tipu token-a i njegovu dužinu ali ne i 
sam podatak.

\begin{listing}[H]
\begin{minted}{rust}
#[derive(Debug)]
pub struct Token {
    pub kind: TokenKind,
    pub len: u32,
}   
\end{minted}
\caption{Definicija "Token" strukture}
\end{listing}

\subsubsection{rustc\_parse::lexer}

Lekser višeg nivoa \verb|rustc_parse::lexer| koristi \verb|rustc_lexer| prilikom izvršavanja sopstvenih
operacija. Bitna razlika je to što se sadržaj token analizira i postavlja u kontekst.
Lekser višeg nivoa koristi kursor svog prethodnika za dobavljanje leksema ali unutar strukture \verb|StringReader|. 

\begin{listing}[H]
\begin{minted}{rust}
    struct StringReader<'psess, 'src> {
        psess: &'psess ParseSess,
        start_pos: BytePos,
        pos: BytePos,
        src: &'src str,
        cursor: Cursor<'src>,
        override_span: Option<Span>,
        nbsp_is_whitespace: bool,
        last_lifetime: Option<Span>,
    }
\end{minted}
\caption{Definicija "StringReader" strukture}
\end{listing}
\verb|StringReader| prati trenutnu poziciju unutar izvornog koda, a kursor 
dobavlja token koji ima odredjenu dužinu. Sadržaj tokena je niz karaktera sa početkom u \verb|pos|,
dužine od \verb|token.len|. 

Prolaskom kroz izvorni kod izvršavaju se sledeće akcije:
\begin{enumerate}
    \item Interniranje 
    \item Tokeni iz \verb|rustc_lexer| se mapiraju na tokene iz \verb|rustc_ast|
    \item Rezulucija zagrada svih tipova.
    \item Problemi i preporuke generišu dijagnostiku 
\end{enumerate}

Interniranje je proces u kome se stringovi pretvaraju internirane simbole. Na ovaj način
se čuva samo jedna nepromenljiva kopija sadržaja tokena. Tabela simbola je struktura podataka
koja čuva i održava O(1) pristup bilo kom simbolu.  Tabela simbola je implementirana pomoću \verb|IndexSet|
strukture. Ne internira se svaki token, već samo tokeni koji imaju varijabilnu dužinu.

Mapiranje tokena iz leksera u tip tokena iz apstraktnog sintaksnog stabla je trivialno.
Za proste tipove vrši se jedan na jedan konverzija.

\begin{listing}[H]
\begin{minted}{rust}
    rustc_lexer::TokenKind::Semi => token::Semi,
    rustc_lexer::TokenKind::Comma => token::Comma,
    rustc_lexer::TokenKind::Dot => token::Dot,
\end{minted}
\caption{Prevodjenje tokena iz leksera u AST tokene}
\end{listing}
Za tipove koji imaju sadržaj u vidu nizova karaktera, sadržaj se internira i prenosi 
u novi token putem simbola. Apstraktno sintaksno stablo se često koristi prilikom kompajliranja i zbog tog razloga 
mora biti memorijski optimizovano.

\begin{listing}[H]
\begin{minted}{rust}
    let ident = Symbol::intern(lifetime_name);
    token::Lifetime(ident, IdentIsRaw::No)
\end{minted}
\caption{Interniranje literala}
\end{listing}
U primeru se može uočiti da \verb|ast_token|-i po potrebi mogu da imaju i dodatne parametre.

Tok tokena je skup stabala tokena od kojih je svako stablo sačinjeno od skupa tokena.  
Rezolucija zagrada je proces unutar kog se validira da li je svaka zagrada pravilno zatvorena.
Rezolucija zagrada se dešava u samom vrhu procesa \verb|rustc_parser::lexer|-a 
za vreme kreiranja toka tokena. U kontekstu kompajlera zagrade se nazivaju delimiteri. 
Svaki otvoreni tip delimitera mora biti zatvoren delimiterom istog tipa koji je zatvoren.
Na primer, vitičasta zagrada je tip delimitera koja može biti otvoren (\{) ili zatvoren (\}) tj.
svaka otvorena vitičasta zagrada mora biti zatvorena zatvorenom vitičastom zagradom.

\begin{listing}[H]
\begin{minted}{rust}
fn lex_token_trees(
    &mut self,
    is_delimited: bool,
) -> (Spacing, TokenStream, Result<(), Vec<PErr<'psess>>>) {
    // Move past the opening delimiter.
    let (_, open_spacing) = self.bump(false);
    let mut buf = Vec::new();
    loop {
        match self.token.kind {
            token::OpenDelim(delim) => buf.push(match self
            .lex_token_tree_open_delim(delim) {
                Ok(val) => val,
                Err(errs) => return (open_spacing, 
                TokenStream::new(buf), Err(errs)),
            }),
            token::CloseDelim(delim) => {
                return (
                    open_spacing,
                    TokenStream::new(buf),
                    if is_delimited { 
                        Ok(()) 
                    } else { Err(vec![self.close_delim_err(delim)]) },
                );
            }
            token::Eof => {
                return (
                    open_spacing,
                    TokenStream::new(buf),
                    if is_delimited { Err(vec![self.eof_err()]) } 
                    else { Ok(()) },
                );
            }
            _ => {
                // Get the next normal token.
                let (this_tok, this_spacing) = self.bump(true);
                buf.push(TokenTree::Token(this_tok, this_spacing));
    } } } }
\end{minted}
\caption{Generisanje stabla tokena}
\end{listing}

\newpage

Primećuje se da u slučaju da kada delimiter ne postoji, dodavanje tokena u tok tokena 
je sekvencijalno i ne zahteva nikakvu kompleksnu logiku. Promenljiva \verb|is_delimited|
označava da li trenutna sekvenca tokena pripada nekom paru delimitera. U slučaju da 
se naidje na zatvoren tip delimitera bez da je prethodno postojao otvoren, vraća se greška
u vidu dijagnostike. U sličnom kontekstu, nailazak na token kraj-a fajla bez da je svaka 
zagrada zatvorena je greška. 
Nailaskom na \verb|token::Eof| ili \verb|token::CloseDelim| se završava prikupljanje toka tokena.
Ovo su veoma korisni granični slučajevi koji omogućavaju rekurziju. 

Obrada otvorenog tipa delimitera u pozadini poziva funkciju \verb|lex_token_trees| koji obradjuje
stablo tokena (deo toka tokena) izmedju novog para zagrada.
\begin{listing}[H]
\begin{minted}{rust}
    fn lex_token_tree_open_delim(
        &mut self,
        open_delim: Delimiter,
    ) -> Result<TokenTree, Vec<PErr<'psess>>> {
        // The span for beginning of the delimited section.
        let pre_span = self.token.span;

        self.diag_info.open_braces.push((open_delim, self.token.span));

        // Lex the token trees within the delimiters.
        // We stop at any delimiter so we can try to recover if the user
        // uses an incorrect delimiter.
        let (open_spacing, tts, res) = self
                            .lex_token_trees(/* is_delimited */ true);
        if let Err(errs) = res {
            return Err(self.unclosed_delim_err(tts, errs));
        }

        // Expand to cover the entire delimited token tree.
        let delim_span = DelimSpan::from_pair(pre_span, self.token.span);
        let sm = self.string_reader.psess.source_map();

        let close_spacing = match self.token.kind {
        .
        .
        .
\end{minted}
\caption{Parsiranje stabla tokena}
\end{listing}

Neobradjene zagrade se čuvaju u strukturi \verb|TokenTreeDiagInfo| u polju \verb|open_braces|.
Utvrdjeno je da će po uspešnom završetku izvršavanja funkcije \verb|lex_token_trees| 
trenutni token biti pozicioniran na zatvoreni tip delimiter-a. To omogućava validaciju 
pravilnog završetka zagrada.

\subsubsection{rustc::parser}

Parser jezika Rust uz pomoć toka tokena iz leksera generiše apstraktno sintaksno stablo (AST). 
Algoritam \verb|recursive-descent| se koristi tokom procesa parsiranja. Ovo je jedna od najjednostavnijih
tehnika parsiranja koja se koristi u praksi. Ovakvi parseri se takodje nazivaju \verb|top-down| parseri 
jer konstruišu stablo od gore ka dole [2]. 

Parser omogućava da se izvorni fajl pretvori u tok tokena, nakon čega se kreira parser za taj tok tokena, i 
potom izvršava da bi se dobio \verb|Crate| tj. početni čvor AST-a.

\begin{listing}[H]
\begin{minted}{rust}
#[derive(Clone, Encodable, Decodable, Debug)]
pub struct Crate {
    pub attrs: AttrVec,
    pub items: ThinVec<P<Item>>,
    pub spans: ModSpans,
    pub id: NodeId,
    pub is_placeholder: bool,
}
\end{minted}
\caption{Definicija "Crate" strukture}
\end{listing}

\begin{listing}[H]
\begin{minted}{rust}
pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {
    let (attrs, items, spans) = self.parse_mod(&token::Eof)?;
    Ok(ast::Crate { attrs, items, spans, 
       id: DUMMY_NODE_ID, is_placeholder: false })
}
\end{minted}
\caption{Ulazna funkcija parsera}
\end{listing}





\newpage
\section{Reference}
[1] MSRC, “A proactive approach to more secure code | MSRC Blog | 
Microsoft Security Response Center,” Microsoft.com, Jul. 16, 2019. 
\url{https://msrc.microsoft.com/blog/2019/07/a-proactive-approach-to-more-secure-code/} 
(pristupljeno Sep. 08, 2024).

[2] “Parsing” Rochester.edu, 2024.
\url{https://www.cs.rochester.edu/u/nelson/courses/csc_173/grammars/parsing.html#:~:text=Recursive%2Ddescent%20parsing%20is%20one,non%2Dterminal%20with%20a%20procedure}
(pristupljeno Sep. 21, 2024).

\end{document}
